use crate::{builtin_interfaces::Time, std_msgs};
use serde_derive::{Deserialize, Serialize};

/// The DmaBuf message is used to transfer a DMA buffer file descriptor between
/// processes. It is mainly used to transfer the camera image data from the
/// camera driver to the image processing nodes.
///
/// The DmaBuf message works by publishing the service's pid and the file
/// descriptor of the DMA buffer.  The receiving node can then use the file
/// descriptor to map the DMA buffer into its own memory space using the
/// [pidfd_open(2)](https://man7.org/linux/man-pages/man2/pidfd_open.2.html)
/// system call on Linux.
///
/// The camera frame widht, height, stride, and fourcc code are included in the
/// message to allow the receiving node interpret the image data.  The length
/// field is the size of the DMA buffer in bytes and used to
/// [mmap(3p)](https://man7.org/linux/man-pages/man3/mmap.3p.html) the buffer.
#[derive(Serialize, Deserialize, PartialEq, Clone)]
pub struct DmaBuf {
    /// Message header containing the timestamp and frame id.
    pub header: std_msgs::Header,
    /// The process id of the service that created the DMA buffer.
    pub pid: u32,
    /// The file descriptor of the DMA buffer.  Used together with the pid to
    /// retrieve the dmabuf into the receiving node's execution context.
    pub fd: i32,
    /// The width of the image in pixels.
    pub width: u32,
    /// The height of the image in pixels.
    pub height: u32,
    /// The stride of the image in bytes.  The stride is used to separate the
    /// rows of the image.  It is typially the same as the width in, accounting
    /// for the pixel size, but may be larger for alignment or cropping reasons.
    pub stride: u32,
    /// The fourcc code of the image.  The fourcc code is a 32-bit integer that
    /// represents the image format.  It is typically a four character code
    /// such as 'YUYV' or 'RGBA'.
    pub fourcc: u32,
    /// The length of the DMA buffer in bytes, used to mmap the buffer.  It can
    /// be larger than the actual image data size.
    pub length: u32,
}

/// The RadarCube interface carries various radar cube reprensentations of the
/// Radar FFT before generally being processed by CFAR into a point cloud.  The
/// cube could provide R, RD, RAD, RA, and so on where R=Range, D=Dopper,
/// and A=Azimuth.  Beyond the common cube dimensions, the cube may also include
/// sequence (chirp), rxchannels, elevation, or undefined dimensions.
///
/// The scales vector is used to convert the cube bins to physical units.  This
/// is used for the range, doppler, azimuth, and elevation dimensions.  For
/// example a range scaling value of 2.5 would mean that each bin in the range
/// dimension is 2.5 meters, so a signal in the 10th bin would be 25 meters away.
///
/// The cube is represented as a 3D array of signed 16-bit integers.  The cube
/// will generally use complex numbers to represent the radar data, the field
/// is_complex is used to indicate if the cube is complex in which case each
/// element is a complex number with the real part followed by the imaginary.
///
/// The header's frame_id field stores the frame id generated by the radar
/// module.  When capturing both the radar cube and point cloud from the module
/// the frame id can be used to correlate the two messages.
#[derive(Serialize, Deserialize, PartialEq, Clone)]
pub struct RadarCube {
    /// Message header containing the timestamp and frame id.
    pub header: std_msgs::Header,
    /// The timestamp of the radar cube data as generated by the radar module.
    pub timestamp: u64,
    /// The layout of the radar cube.  The layout is a vector of dimension labels
    /// that describe the order of the dimensions in the cube.  The labels are
    /// defined in the radar_cube_dimension module.
    pub layout: Vec<u8>,
    /// The shape of the radar cube.
    pub shape: Vec<u16>,
    /// The scales vector is used to convert the cube bins to physical units.
    pub scales: Vec<f32>,
    /// The radar cube data.  The cube is represented as a 3D array of signed
    /// 16-bit integers.  If the cube is complex as indicated by the is_complex
    /// field, then the elements should be interpred as pairs of real and
    /// imaginary values.
    pub cube: Vec<i16>,
    /// The cube uses complex numbers if true.
    pub is_complex: bool,
}

/// Dimensional labels are used to describe the radar cube layout. Not all cubes
/// include every label.  Undefined is used for dimensions not covered by this
/// list.  For example the Raivin radar cube is in the sequence, range,
/// rxchannel, and doppler dimensions.  These labels can be used so applications
/// can interpret the radar cube data genericly and portably between different
/// radar modules.
pub mod radar_cube_dimension {
    pub const UNDEFINED: u8 = 0;
    pub const RANGE: u8 = 1;
    pub const DOPPLER: u8 = 2;
    pub const AZIMUTH: u8 = 3;
    pub const ELEVATION: u8 = 4;
    pub const RXCHANNEL: u8 = 5;
    pub const SEQUENCE: u8 = 6;
}

#[derive(Serialize, Deserialize, PartialEq, Clone)]
pub struct Detect {
    pub header: std_msgs::Header,
    pub input_timestamp: Time,
    pub model_time: Time,
    pub output_time: Time,
    pub boxes: Vec<DetectBox2D>,
}
#[derive(Serialize, Deserialize, PartialEq, Clone)]
pub struct DetectBox2D {
    pub center_x: f32,
    pub center_y: f32,
    pub width: f32,
    pub height: f32,
    pub label: String,
    pub score: f32,
    pub distance: f32,
    pub speed: f32,
    pub track: DetectTrack,
}
#[derive(Serialize, Deserialize, PartialEq, Clone)]
pub struct DetectTrack {
    pub id: String,
    pub lifetime: i32,
    pub created: Time,
}
