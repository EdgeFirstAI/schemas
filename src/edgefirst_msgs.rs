use std::time::Duration;

use crate::{
    builtin_interfaces::Time,
    std_msgs::{self, Header},
};
use serde_derive::{Deserialize, Serialize};

/// The DmaBuf message is used to transfer a DMA buffer file descriptor between
/// processes. It is mainly used to transfer the camera image data from the
/// camera driver to the image processing nodes.
///
/// The DmaBuf message works by publishing the service's pid and the file
/// descriptor of the DMA buffer.  The receiving node can then use the file
/// descriptor to map the DMA buffer into its own memory space using the
/// [pidfd_open(2)](https://man7.org/linux/man-pages/man2/pidfd_open.2.html)
/// system call on Linux.
///
/// The camera frame widht, height, stride, and fourcc code are included in the
/// message to allow the receiving node interpret the image data.  The length
/// field is the size of the DMA buffer in bytes and used to
/// [mmap(3p)](https://man7.org/linux/man-pages/man3/mmap.3p.html) the buffer.
#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct DmaBuf {
    /// Message header containing the timestamp and frame id.
    pub header: std_msgs::Header,
    /// The process id of the service that created the DMA buffer.
    pub pid: u32,
    /// The file descriptor of the DMA buffer.  Used together with the pid to
    /// retrieve the dmabuf into the receiving node's execution context.
    pub fd: i32,
    /// The width of the image in pixels.
    pub width: u32,
    /// The height of the image in pixels.
    pub height: u32,
    /// The stride of the image in bytes.  The stride is used to separate the
    /// rows of the image.  It is typially the same as the width in, accounting
    /// for the pixel size, but may be larger for alignment or cropping reasons.
    pub stride: u32,
    /// The fourcc code of the image.  The fourcc code is a 32-bit integer that
    /// represents the image format.  It is typically a four character code
    /// such as 'YUYV' or 'RGBA'.
    pub fourcc: u32,
    /// The length of the DMA buffer in bytes, used to mmap the buffer.  It can
    /// be larger than the actual image data size.
    pub length: u32,
}

/// The RadarCube interface carries various radar cube reprensentations of the
/// Radar FFT before generally being processed by CFAR into a point cloud.  The
/// cube could provide R, RD, RAD, RA, and so on where R=Range, D=Dopper,
/// and A=Azimuth.  Beyond the common cube dimensions, the cube may also include
/// sequence (chirp), rxchannels, elevation, or undefined dimensions.
///
/// The scales vector is used to convert the cube bins to physical units.  This
/// is used for the range, doppler, azimuth, and elevation dimensions.  For
/// example a range scaling value of 2.5 would mean that each bin in the range
/// dimension is 2.5 meters, so a signal in the 10th bin would be 25 meters away.
///
/// The cube is represented as a 3D array of signed 16-bit integers.  The cube
/// will generally use complex numbers to represent the radar data, the field
/// is_complex is used to indicate if the cube is complex in which case each
/// element is a complex number with the real part followed by the imaginary.
///
/// The header's frame_id field stores the frame id generated by the radar
/// module.  When capturing both the radar cube and point cloud from the module
/// the frame id can be used to correlate the two messages.
#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct RadarCube {
    /// Message header containing the timestamp and frame id.
    pub header: std_msgs::Header,
    /// The timestamp of the radar cube data as generated by the radar module.
    pub timestamp: u64,
    /// The layout of the radar cube.  The layout is a vector of dimension labels
    /// that describe the order of the dimensions in the cube.  The labels are
    /// defined in the radar_cube_dimension module.
    pub layout: Vec<u8>,
    /// The shape of the radar cube.
    pub shape: Vec<u16>,
    /// The scales vector is used to convert the cube bins to physical units.
    pub scales: Vec<f32>,
    /// The radar cube data.  The cube is represented as a 3D array of signed
    /// 16-bit integers.  If the cube is complex as indicated by the is_complex
    /// field, then the elements should be interpred as pairs of real and
    /// imaginary values.
    pub cube: Vec<i16>,
    /// The cube uses complex numbers if true.
    pub is_complex: bool,
}

/// Dimensional labels are used to describe the radar cube layout. Not all cubes
/// include every label.  Undefined is used for dimensions not covered by this
/// list.  For example the Raivin radar cube is in the sequence, range,
/// rxchannel, and doppler dimensions.  These labels can be used so applications
/// can interpret the radar cube data genericly and portably between different
/// radar modules.
pub mod radar_cube_dimension {
    pub const UNDEFINED: u8 = 0;
    pub const RANGE: u8 = 1;
    pub const DOPPLER: u8 = 2;
    pub const AZIMUTH: u8 = 3;
    pub const ELEVATION: u8 = 4;
    pub const RXCHANNEL: u8 = 5;
    pub const SEQUENCE: u8 = 6;
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct Detect {
    pub header: std_msgs::Header,
    pub input_timestamp: Time,
    pub model_time: Time,
    pub output_time: Time,
    pub boxes: Vec<DetectBox2D>,
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct DetectBox2D {
    pub center_x: f32,
    pub center_y: f32,
    pub width: f32,
    pub height: f32,
    pub label: String,
    pub score: f32,
    pub distance: f32,
    pub speed: f32,
    pub track: DetectTrack,
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct DetectTrack {
    pub id: String,
    pub lifetime: i32,
    pub created: Time,
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct Mask {
    /// The height of the mask, 0 if this dimension is unused.
    pub height: u32,
    /// The width of the mask, 0 if this dimension is unused.
    pub width: u32,
    /// The length of the mask, 0 if this dimension is unused.  The length would
    /// be used in 3D masks to represent the depth.  It could also be used for 2D
    /// bird's eye view masks along with width instead of height (elevation).
    pub length: u32,
    /// The optional encoding for the mask (currently unused).
    pub encoding: String,
    /// The segmentation mask data.  The array should be reshaped according to the
    /// height, width, and length dimensions.  The dimension order is row-major.
    pub mask: Vec<u8>,
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct Model {
    /// Message header containing the timestamp and frame id.
    pub header: Header,
    /// Duration to load inputs into the model.
    pub input_time: Duration,
    /// Duration to run the model, not including input/output/decoding.
    pub model_time: Duration,
    /// Duration to read the outputs from the model.
    pub output_time: Duration,
    /// Duration to decode the outputs from the model, including nms and tracking.
    pub decode_time: Duration,
    /// Box detections from the model.  Empty if none detected or if model does
    /// not support detection.
    pub boxes: Vec<DetectBox2D>,
    /// Segmentation masks from the model.  Empty array if model does not generate
    /// masks.  Generally models will only generate a single mask if they do.
    pub masks: Vec<Mask>,
}

pub mod model_info {
    pub const RAW: u8 = 0;
    pub const INT8: u8 = 1;
    pub const UINT8: u8 = 2;
    pub const INT16: u8 = 3;
    pub const UINT16: u8 = 4;
    pub const FLOAT16: u8 = 5;
    pub const INT32: u8 = 6;
    pub const UINT32: u8 = 7;
    pub const FLOAT32: u8 = 8;
    pub const INT64: u8 = 9;
    pub const UINT64: u8 = 10;
    pub const FLOAT64: u8 = 11;
    pub const STRING: u8 = 12;
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct ModelInfo {
    pub header: Header,
    pub input_shape: Vec<u32>,
    pub input_type: u8,
    pub output_shape: Vec<u32>,
    pub output_type: u8,
    pub labels: Vec<String>,
    pub model_type: String,
    pub model_format: String,
    pub model_name: String,
}

/// The local time interface publishes the current time on the device.  It is
/// mainly intended to allow synchronization of multiple MCAP files by the Maivin
/// Publisher.  The idea is to calculate the offset from the timestamp in the
/// header with the actual local time, then when multiple MCAP files have the
/// local time topic recorded the relative offsets can then be calculated.
#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct LocalTime {
    /// Message header containing the timestamp and frame id.
    pub header: Header,
    /// The base date from which the local time is calculated.  This could be an
    /// epoch such as the standard UNIX 1 January 1970 or it could be the current
    /// date.  To calculate the real local time both the date, time, and timezone
    /// are combined into a valid date and time.
    pub date: Date,
    /// The time offset from the date.  If the date is the current day then the
    /// time is the normal time of day.  If the date is an epoch than many days
    /// will be represented in the time.
    pub time: Time,
    /// The timezone offset in minutes from UTC of the time value.  The timezone
    /// would be +/- 720 (+/- 12 hours).  Minutes are used to allow for partial
    /// offsets such as Newfoundland in Canada which is UTC-210 (UTC-3h30).
    pub timezone: i16,
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct Date {
    pub year: u16,
    pub month: u8,
    pub day: u8,
}
